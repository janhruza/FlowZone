using FZCore;
using FZCore.Windows;

using System;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows;

using WebPeek.Core;

namespace WebPeek.Windows;

/// <summary>
/// Representing the window for adding a new application.
/// </summary>
public partial class WndNewApp : IconlessWindow
{
    /// <summary>
    /// Creates a new instance of the <see cref="WndNewApp"/> class.
    /// </summary>
    public WndNewApp()
    {
        InitializeComponent();
        this.webApp = new WebApplication();
        Result = this.webApp;
    }

    private bool bDialog;

    private WebApplication webApp;

    /// <summary>
    /// Representing the result of the application registration.
    /// </summary>
    public WebApplication Result { get; private set; }

    /// <summary>
    /// Ovverrides the Show method to set the dialog state.
    /// </summary>
    public new void Show()
    {
        this.bDialog = false;
        return;
    }

    /// <summary>
    /// Ovverrides the ShowDialog method to set the dialog state and return a nullable boolean.
    /// </summary>
    /// <returns>The window's dialog result.</returns>
    public new bool? ShowDialog()
    {
        this.bDialog = true;
        return base.ShowDialog();
    }

    private void btnCancel_Click(object sender, RoutedEventArgs e)
    {
        if (this.bDialog)
        {
            DialogResult = false;
        }

        Close();
    }

    private bool ExportApp()
    {
        this.webApp = new WebApplication(this.txtName.Text, this.txtUrl.Text);
        return AppManager.RegisterApp(this.webApp);
    }

    private void btnAdd_Click(object sender, RoutedEventArgs e)
    {
        if (ExportApp() == false)
        {
            FZCore.Core.ErrorBox("Failed to register the application. Please check the name and URL.", "Error");
            return;
        }

        Result = this.webApp;

        if (this.bDialog)
        {
            DialogResult = true;
        }

        Close();
    }

    /// <summary>
    /// Retrieves a website title off the given <paramref name="url"/>.
    /// </summary>
    /// <param name="url">Target URL address.</param>
    /// <returns>
    /// 0 if the code succeeded, otherwise a nonzero error value.
    /// </returns>
    /// <remarks>
    /// This method was generated by Google Gemini 3 Pro.
    /// </remarks>
    private static async Task<int> GetPageTitleAsync(string url)
    {
        // Best Practice: In a production app, instantiate HttpClient once (static) or use IHttpClientFactory
        // to avoid socket exhaustion. Using 'using' here for self-contained simplicity.
        using (var client = new HttpClient())
        {
            // 1. Set a User-Agent to simulate a real browser. 
            // Many servers (e.g., Wikipedia, Google) block requests without this header.
            client.DefaultRequestHeaders.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)");

            try
            {
                // 2. Start the request but ONLY download the headers initially.
                // This is crucial for performance - we do not wait for the full body.
                using (HttpResponseMessage response = await client.GetAsync(url, HttpCompletionOption.ResponseHeadersRead))
                {
                    response.EnsureSuccessStatusCode();

                    // 3. Open a stream to read the body content byte-by-byte (or chunk-by-chunk)
                    using (Stream stream = await response.Content.ReadAsStreamAsync())
                    using (StreamReader reader = new StreamReader(stream))
                    {
                        string contentBuffer = "";
                        char[] buffer = new char[512]; // Read in small 512-character chunks
                        int bytesRead;

                        // 4. Loop through the stream
                        while ((bytesRead = await reader.ReadAsync(buffer, 0, buffer.Length)) > 0)
                        {
                            // Append the new chunk to our local string buffer
                            contentBuffer += new string(buffer, 0, bytesRead);

                            // 5. Check if we have found the title tags using Regex
                            // Pattern: Looks for text between <title> and </title>
                            // Options: IgnoreCase (handles <TITLE>) and Singleline (matches across new lines)
                            Match match = Regex.Match(contentBuffer, @"<title>\s*(.+?)\s*</title>", RegexOptions.IgnoreCase | RegexOptions.Singleline);

                            if (match.Success)
                            {
                                // 6. Title found! 
                                // Decode HTML entities (e.g., converts "&amp;" to "&") and return immediately.
                                // This automatically disposes the stream and stops downloading the rest of the page.
                                _fetchedTitle =  WebUtility.HtmlDecode(match.Groups[1].Value);
                                return 0;
                            }

                            // 7. Safety break: If we've read 2MB and haven't found a title, stop.
                            // The title is almost always in the <head>, which is at the very top.
                            // This prevents downloading megabytes of data if the <title> tag is missing.
                            if (contentBuffer.Length > 20000)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            catch (HttpRequestException e)
            {
                // Handle network errors (DNS, 404, etc.)
                Log.Error(e, nameof(GetPageTitleAsync));
                return e.HResult;
            }

            catch (Exception e)
            {
                // Handle other errors
                Log.Error(e, nameof(GetPageTitleAsync));
                return e.HResult;
            }
        }

        // generic failure when the title was not found
        return -1;
    }

    private static string _fetchedTitle = string.Empty;

    private async void btnFetchTitle_Click(object sender, RoutedEventArgs e)
    {
        if (await GetPageTitleAsync(txtUrl.Text) != 0)
        {
            FZCore.Core.ErrorBox($"Unable to retrieve the title of the website.", "Retrieve title");
            return;
        }

        // update the title field
        txtName.Text = _fetchedTitle;
        return;
    }
}
